/*globals define, WebGMEGlobal*/
/**
 * Generated by VisualizerGenerator 1.7.0 from webgme on Fri May 05 2023 10:01:31 GMT-0500 (Central Daylight Time).
 */

define([
    'js/Constants',
    'js/Utils/GMEConcepts',
    'js/NodePropertyNames',
    'js/Dialogs/Projects/ProjectsDialog',
    'blob/BlobClient',
    'js/Loader/ProgressNotification'
], function (
    CONSTANTS,
    GMEConcepts,
    nodePropertyNames,
    ProjectsDialog,
    BlobClient,
    ProgressNotification
) {

    'use strict';

    function WorkflowBrowserControl(options) {

        this._logger = options.logger.fork('Control');
        this._client = options.client;
        this._currentNodeId = null;
        this._updateWidget = null;
        this._descriptor = null;

        //build meta info - does it necessary? where is the shorthand?
        this._META = {};
        this._id2meta = {};
        this._client.getAllMetaNodes(false).forEach(metaNode => {
            this._META[metaNode.getFullyQualifiedName()] = metaNode;
            this._id2meta[metaNode.getId()] = metaNode.getFullyQualifiedName();
        });

        this._eventCallback = this._eventCallback.bind(this);
        this._logger.debug('ctor finished');
    }

    /* * * * * * * * Visualizer content update callbacks * * * * * * * */
    // One major concept here is with managing the territory. The territory
    // defines the parts of the project that the visualizer is interested in
    // (this allows the browser to then only load those relevant parts).
    WorkflowBrowserControl.prototype.selectedObjectChanged = function (nodeId) {
        const {_logger, _client, _eventCallback} = this;

        _logger.debug('activeObject nodeId \'' + nodeId + '\'');

        // Remove current territory patterns
        if (this._currentNodeId) {
            _client.removeUI(this._territoryId);
        }

        this._currentNodeId = nodeId;

        if (typeof this._currentNodeId === 'string' && this._currentNodeId === '/f') {
            // Put new node's info into territory rules
            this._selfPatterns = {};
            this._selfPatterns['/f'] = {children: 1}; //all workflows in the project

            this._territoryId = _client.addUI(this, events => {
                _eventCallback(events);
            });

            // Update the territory
            _client.updateTerritory(this._territoryId, this._selfPatterns);
        }
    };

    // This next function retrieves the relevant node information for the widget
    WorkflowBrowserControl.prototype._createDescriptor = function () {
        const {_client, _META, _updateWidget, _currentNodeId} = this;
        if (typeof _currentNodeId === 'string') {
            const descriptor = {locals:[]};
            const node = _client.getNode(_currentNodeId);
            node.getChildrenIds().forEach(childId => {
                const desc = {id: childId};
                const child = _client.getNode(childId);
                if(child.isInstanceOf(_META['CWL.Workflow'].getId())) {
                    desc.name = child.getAttribute('name');
                    desc.documentation = child.getAttribute('documentation');
                    descriptor.locals.push(desc);
                }
            });
            this._descriptor = descriptor;
            if(_updateWidget) {
                _updateWidget(descriptor);
            }
        }
    };

    /* * * * * * * * Node Event Handling * * * * * * * */
    WorkflowBrowserControl.prototype._eventCallback = function (events) {
        var i = events ? events.length : 0,
            event;

        this._logger.debug('_eventCallback \'' + i + '\' items');
        // if(this._updateWidget !== null) {
            // console.log('we got widget connection');
            // this._updateWidget([],[],{});
        // }

        if (events[0] && events[0].etype === 'complete') {
            //we have what we need
            this._createDescriptor();
        }
        this._logger.debug('_eventCallback \'' + events.length + '\' items - DONE');
    };


    WorkflowBrowserControl.prototype._stateActiveObjectChanged = function (model, activeObjectId) {
        if (this._currentNodeId === activeObjectId) {
            // The same node selected as before - do not trigger
        } else {
            this.selectedObjectChanged(activeObjectId);
        }
    };

    WorkflowBrowserControl.prototype.deleteComponent = function (id) {
        const {_client} = this;
        _client.deleteNode(id);
    };

    WorkflowBrowserControl.prototype.openProjectManager = function () {
        const {_client} = this;
        const pd = new ProjectsDialog(_client);
        pd.show();
    };

    WorkflowBrowserControl.prototype.createEmptyWorkflow = function (name) {
        const {_client, _META} = this;
        const newid = _client.createNode(
            {parentId:'/f', baseId:_META['CWL.Workflow'].getId()},
            {attributes: {name: name}},
            'adding new worklfow [' + name + ']');
        return newid;
    };

    WorkflowBrowserControl.prototype.runExportPlugin = function (workflowId) {
        const {_client, _logger} = this;
        const bc = new BlobClient({logger: _logger.fork('BlobClient')});
        const context = _client.getCurrentPluginContext('ExportWorkflow');
        context.managerConfig.activeNode = workflowId;
        context.managerConfig.namespace = 'CWL';
        context.pluginConfig = {};

        _client.runBrowserPlugin('ExportWorkflow', context, (err, result)=>{
            // console.log('export:', err, result);
            if (err === null && result && result.success) {
                const url = bc.getDownloadURL(result.artifacts[0]);
                window.open(url, '_blank');
            } else {
                //TODO - make a proper way of handling this
                _logger.error('Failed to export', err);
            }
        });
    };

    WorkflowBrowserControl.prototype.runCheckPlugin = function (workflowId) {
        const {_client, _logger} = this;
        const bc = new BlobClient({logger: _logger.fork('BlobClient')});
        const context = _client.getCurrentPluginContext('CheckWorkflow');
        context.managerConfig.activeNode = workflowId;
        context.managerConfig.namespace = 'CWL';
        context.pluginConfig = {};

        _client.runBrowserPlugin('CheckWorkflow', context, (err, result)=>{
            // console.log('check:', err, result);
            let text = 'Checking finished<br/>';
            const options = {type:'info'};
            let icon = 'glyphicon glyphicon-info-sign';
            if(!result.success) {
                options.type = 'warning';
            }
            if(result.messages.length > 0) {
                result.messages.forEach(message => {
                    text += message.severity === 'warning' ? '[W] - ' : '[E] - ';
                    text += '{'+ message.activeNode.name + '} - ';
                    text += message.message +'<br/>';
                });
            }
            $.notify({icon: icon, message: text}, options);
        });
    };

    WorkflowBrowserControl.prototype.runBuildPlugin = function (workflowId) {
        const {_client, _logger} = this;
        const bc = new BlobClient({logger: _logger.fork('BlobClient')});
        const context = _client.getCurrentPluginContext('BuildWorkflow');
        context.managerConfig.activeNode = workflowId;
        context.managerConfig.namespace = 'CWL';
        context.pluginConfig = {};

        _client.runBrowserPlugin('BuildWorkflow', context, (err, result)=>{
            // console.log('export:', err, result);
            if (err === null && result && result.success) {
                const url = bc.getDownloadURL(result.artifacts[0]);
                window.open(url, '_blank');
            } else {
                //TODO - make a proper way of handling this
                _logger.error('Failed to build', err);
            }
        });
    };

    WorkflowBrowserControl.prototype.runReleasePlugin = function (workflowId) {
        const progress = ProgressNotification.start('Releasing workflow');
        let metadata = WebGMEGlobal.allPluginsMetadata['ReleaseWorkflow'];
        metadata['__context'] = {activeNodeId: workflowId, activeSelectionIds: []};
        WebGMEGlobal.InterpreterManager.configureAndRun(metadata, function (result) {
            let text = 'PluginRelease finished<br/>';
            const options = {type:'info'};
            let icon = 'glyphicon glyphicon-info-sign';
            if (result.success) {
                text += "- success -<br/>"
                if(result.messages.length > 0) {
                    result.messages.forEach(message => {
                        text += ' -- ' + message.message +'<br/>';
                    });
                }
                progress.note.update({
                    message: text,
                    progress: 100,
                    type: 'success'
                });
            } else {
                icon = 'glyphicon glyphicon-exclamation-sign';
                text += "- faliure -<br/>";
                options.type = 'warning';
                text += result.error ? result.error : 'Unknown error happened during execution!';
                progress.note.update({
                    message: text,
                    type: 'danger',
                    progress: 100
                });
            }
            // $.notify({icon: icon, message: text}, options);
        });
    };
    
    WorkflowBrowserControl.prototype.runImportPlugin = function () {
        const progress = ProgressNotification.start('Importing workflow');
        WebGMEGlobal.InterpreterManager.configureAndRun(WebGMEGlobal.allPluginsMetadata['ImportWorkflow'], result => {
            console.log('import res', result);
            if(result.success) {
                progress.note.update({
                    message: 'finished importing',
                    progress: 100,
                    type: 'success'
                });
            } else {
                progress.note.update({
                    message: 'import failed!',
                    type: 'danger',
                    progress: 100
                });
            }
          });
    };

    WorkflowBrowserControl.prototype.runFetchPlugin = function () {
        const progress = ProgressNotification.start('Fetching workflow from repository');
        WebGMEGlobal.InterpreterManager.configureAndRun(WebGMEGlobal.allPluginsMetadata['FetchWorkflow'], result => {
            console.log('fetch res', result);
            if(result.success) {
                progress.note.update({
                    message: 'finished fetching',
                    progress: 100,
                    type: 'success'
                });
            } else {
                progress.note.update({
                    message: 'fetch failed!',
                    type: 'danger',
                    progress: 100
                });
            }
          });
    };

    WorkflowBrowserControl.prototype.getCurrentWorkflowDescription = function(workflowId) {
        const {_client} = this;
        const node = _client.getNode(workflowId);

        if (node) {
            return node.getAttribute('documentation');
        } else {
            return null;
        }
    };

    WorkflowBrowserControl.prototype.setWorkflowDescription = function(description) {
        const {_client} = this;

        _client.setAttribute(description.id, 'documentation', description.text);
    };

    WorkflowBrowserControl.prototype.updateCoreLibrary = function() {
        const {_client} = this;

        _client.updateLibrary('CWL','cwl_core', (err, result) => {
            console.log(err);
            console.log(result);
        });
    };

    /* * * * * * * * Visualizer life cycle callbacks * * * * * * * */
    WorkflowBrowserControl.prototype.destroy = function () {
        this._detachClientEventListeners();
        this._removeToolbarItems();
    };

    WorkflowBrowserControl.prototype._attachClientEventListeners = function () {
        this._detachClientEventListeners();
        WebGMEGlobal.State.on('change:' + CONSTANTS.STATE_ACTIVE_OBJECT, this._stateActiveObjectChanged, this);
    };

    WorkflowBrowserControl.prototype._detachClientEventListeners = function () {
        WebGMEGlobal.State.off('change:' + CONSTANTS.STATE_ACTIVE_OBJECT, this._stateActiveObjectChanged);
    };

    WorkflowBrowserControl.prototype.onActivate = function () {
        this._attachClientEventListeners();
        // this._displayToolbarItems();

        if (typeof this._currentNodeId === 'string') {
            WebGMEGlobal.State.registerActiveObject(this._currentNodeId, {suppressVisualizerFromNode: true});
        }
    };

    WorkflowBrowserControl.prototype.onDeactivate = function () {
        this._detachClientEventListeners();
        this._hideToolbarItems();
    };

    WorkflowBrowserControl.prototype.registerUpdate = function (func) {
        const firstTry = this._updateWidget === null ? true : false;
        this._updateWidget = func;
        if(this._descriptor && firstTry) {
            this._updateWidget(this._descriptor);
        }
    };
    /* * * * * * * * * * Updating the toolbar * * * * * * * * * */
    WorkflowBrowserControl.prototype._displayToolbarItems = function () {

        if (this._toolbarInitialized === true) {
            for (var i = this._toolbarItems.length; i--;) {
                this._toolbarItems[i].show();
            }
        } else {
            this._initializeToolbar();
        }
    };

    WorkflowBrowserControl.prototype._hideToolbarItems = function () {

        if (this._toolbarInitialized === true) {
            for (var i = this._toolbarItems.length; i--;) {
                this._toolbarItems[i].hide();
            }
        }
    };

    WorkflowBrowserControl.prototype._removeToolbarItems = function () {

        if (this._toolbarInitialized === true) {
            for (var i = this._toolbarItems.length; i--;) {
                this._toolbarItems[i].destroy();
            }
        }
    };

    WorkflowBrowserControl.prototype._initializeToolbar = function () {
        var self = this,
            toolBar = WebGMEGlobal.Toolbar;

        this._toolbarItems = [];

        this._toolbarItems.push(toolBar.addSeparator());

        /************** Go to hierarchical parent button ****************/
        this.$btnModelHierarchyUp = toolBar.addButton({
            title: 'Go to parent',
            icon: 'glyphicon glyphicon-circle-arrow-up',
            clickFn: function (/*data*/) {
                WebGMEGlobal.State.registerActiveObject(self._currentNodeParentId);
            }
        });
        this._toolbarItems.push(this.$btnModelHierarchyUp);
        this.$btnModelHierarchyUp.hide();

        /************** Checkbox example *******************/

        this.$cbShowConnection = toolBar.addCheckBox({
            title: 'toggle checkbox',
            icon: 'gme icon-gme_diagonal-arrow',
            checkChangedFn: function (data, checked) {
                self._logger.debug('Checkbox has been clicked!');
            }
        });
        this._toolbarItems.push(this.$cbShowConnection);

        this._toolbarInitialized = true;
    };

    return WorkflowBrowserControl;
});
