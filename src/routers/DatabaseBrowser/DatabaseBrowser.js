/*globals define*/

/**
 * Generated by RestRouterGenerator 2.2.0 from webgme on Tue Jul 19 2022 10:15:31 GMT-0500 (Central Daylight Time).
 * To use in webgme add to gmeConfig.rest.components[DatabaseBrowser] = {
 *    mount: 'path/subPath',
 *    src: path.join(process.cwd(), './DatabaseBrowser'),
 *    options: {}
 * }
 * If you put this file in the root of your directory the above will expose the routes at
 * <host>/path/subPath, for example GET <host>/path/subPath/getExample will be routed to the getExample below.
 */

'use strict';

// http://expressjs.com/en/guide/routing.html
var express = require('express'),
    path = require('path'),
    fs = require('fs'),
    router = express.Router(),
    fetch = require('whatwg-fetch'),
    https = require('https'),
    Q = require('q');

const datalakeBaseUrl = 'https://leappremonitiondev.azurewebsites.net/v2/';

function getAccessToken(server, userId) {
    console.log('getting access token from self!');
    const deferred = Q.defer();
    server.__aadClient.getAccessToken(userId)
    .then(token=> {
        console.log('there you are:',token);
        deferred.resolve(token);
    })
    .catch(err => {
        console.error(err);
        // deferred.reject(err);
        deferred.resolve('mytoken');
    });

    return deferred.promise;   
}

function gatherDataFromLake (type, accessToken) {
    console.log('getting data from the lake');
    const deferred = Q.defer();

    /*
    fetch(datalakeBaseUrl+'Process/ListProcesses?permission=read')
    .then(res => {
        console.log(res);
        return res.json();
    })
    .then(res => {
        console.log(res);
        deferred.resolve(res);
    })
    .catch(err => {
        console.log(err);
        deferred.reject;
    });

    */
    const options = {
        hostname: 'leappremonitiondev.azurewebsites.net',
        path:'/v2/Process/ListProcesses/?permission=read',
        port:443,
        method:'GET',
        headers: {
            'Authorization': "Bearer " + accessToken
          }
    };
    const req = https.request(options, res => {
        console.log('status:', res.statusCode);

        res.on('data', d => {
            console.log(d);
        });

        if(res.statusCode !== 200) {
            const fakeResult = {
                tags:['one', 'two', 'three'],
                data:[
                    {
                        tags: ['one','three'],
                        pid:'908fd477-155e-43d1-8837-6a11214ebdd4',
                        metadata:{
                            something:1,
                            another:'thing',
                            description:'this is one of your data items representing data'
                        }
                    },
                    {
                        tags: ['one','two'],
                        pid:'3d357bdc-d436-4bc1-99cf-7fa26741edd4',
                        metadata:{
                            something:2,
                            another:'thing',
                            description:'this is another one of your data items representing data'
                        }
                    },
                    {
                        tags: ['one'],
                        pid:'71ecb2c0-c1be-48ee-b2ed-a067c646f1ae',
                        metadata:{
                            something:3,
                            another:'thing',
                            description:'this is one of your data items representing data'
                        }
                    },
                    {
                        tags: ['two'],
                        pid:'68a33221-9bb0-420f-9a3c-d7cfef9536af',
                        metadata:{
                            something:3,
                            another:'thing',
                            description:'this is one of your data items representing data'
                        }
                    },
                    {
                        tags: ['three'],
                        pid:'4935ff85-8e84-4b06-a69a-9ac160542a50',
                        metadata:{
                            something:3,
                            another:'thing',
                            description:'this is one of your data items representing data'
                        }
                    }
                ]
            }
            deferred.resolve(fakeResult);
        }
    });

    req.on('error', err => {
        console.log(err);
        deferred.reject(err);
    });

    req.end();

    return deferred.promise;
}
/**
 * Called when the server is created but before it starts to listening to incoming requests.
 * N.B. gmeAuth, safeStorage and workerManager are not ready to use until the start function is called.
 * (However inside an incoming request they are all ensured to have been initialized.)
 *
 * @param {object} middlewareOpts - Passed by the webgme server.
 * @param {GmeConfig} middlewareOpts.gmeConfig - GME config parameters.
 * @param {GmeLogger} middlewareOpts.logger - logger
 * @param {function} middlewareOpts.ensureAuthenticated - Ensures the user is authenticated.
 * @param {function} middlewareOpts.getUserId - If authenticated retrieves the userId from the request.
 * @param {object} middlewareOpts.gmeAuth - Authorization module.
 * @param {object} middlewareOpts.safeStorage - Accesses the storage and emits events (PROJECT_CREATED, COMMIT..).
 * @param {object} middlewareOpts.workerManager - Spawns and keeps track of "worker" sub-processes.
 */
function initialize(middlewareOpts) {
    var logger = middlewareOpts.logger.fork('DatabaseBrowser'),
        ensureAuthenticated = middlewareOpts.ensureAuthenticated,
        getUserId = middlewareOpts.getUserId;

    logger.debug('initializing ...');

    // Ensure authenticated can be used only after this rule.
    router.use('*', function (req, res, next) {
        // TODO: set all headers, check rate limit, etc.

        // This header ensures that any failures with authentication won't redirect.
        res.setHeader('X-WebGME-Media-Type', 'webgme.v1');
        next();
    });

    // Use ensureAuthenticated if the routes require authentication. (Can be set explicitly for each route.)
    router.use('*', ensureAuthenticated);

    const startSearch = (type, req, res) => {
        res.cookie('searchDataType', type);
        const userId = getUserId(req);
        return res.sendFile(path.join(__dirname,'./dist/index.html'));
    };

    router.get('/start/workflow', (req, res) => {
        return startSearch('workflow', req, res);
    });

    router.get('/start/data', (req, res) => {
        return startSearch('data', req, res);
    });

    router.get('/data', (req, res) => {
        console.log('hello data', req.url);
        const type = req.cookies.searchDataType;
        const projectId = req.query.projectid;
        const path = req.query.path;
        console.log(req.cookies);
        const userId = getUserId(req);

        // res.json({any:'thing'});
        console.log('getting access token for user:', userId);
        getAccessToken(middlewareOpts.server, userId)
        .then(aToken => {
            console.log('got access!:', aToken)
            return gatherDataFromLake(type, aToken); 
        })
        .then(data => {
            data.type = type;
            res.json(data);
        })
        .catch(err => {
            console.log(err);
            res.send(500);
        });
    });

    logger.debug('ready');
}

/**
 * Called before the server starts listening.
 * @param {function} callback
 */
function start(callback) {
    callback();
}

/**
 * Called after the server stopped listening.
 * @param {function} callback
 */
function stop(callback) {
    callback();
}


module.exports = {
    initialize: initialize,
    router: router,
    start: start,
    stop: stop
};
