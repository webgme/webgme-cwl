/*globals define*/
/*eslint-env node, browser*/

const { ChildProcess } = require('child_process');

/**
 * Generated by PluginGenerator 2.20.5 from webgme on Wed Apr 27 2022 13:26:17 GMT-0500 (Central Daylight Time).
 * A plugin that inherits from the PluginBase. To see source code documentation about available
 * properties and methods visit %host%/docs/source/PluginBase.html.
 */

define([
    'plugin/PluginConfig',
    'text!./metadata.json',
    'plugin/PluginBase',
    'q'
], function (
    PluginConfig,
    pluginMetadata,
    PluginBase,
    Q) {
    'use strict';

    pluginMetadata = JSON.parse(pluginMetadata);

    /**
     * Initializes a new instance of RunWorkflow.
     * @class
     * @augments {PluginBase}
     * @classdesc This class represents the plugin RunWorkflow.
     * @constructor
     */
    function RunWorkflow() {
        // Call base class' constructor.
        PluginBase.call(this);
        this.pluginMetadata = pluginMetadata;
    }

    /**
     * Metadata associated with the plugin. Contains id, name, version, description, icon, configStructure etc.
     * This is also available at the instance at this.pluginMetadata.
     * @type {object}
     */
    RunWorkflow.metadata = pluginMetadata;

    // Prototypical inheritance from PluginBase.
    RunWorkflow.prototype = Object.create(PluginBase.prototype);
    RunWorkflow.prototype.constructor = RunWorkflow;

    function makeid() {
        const length = 16;
        let result = '';
        const characters = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789';
        const charactersLength = characters.length;
        for (let i = 0; i < length; i += 1 ) {
            result += characters.charAt(Math.floor(Math.random() * charactersLength));
        }
       return result;
    };

    /**
     * Main function for the plugin to execute. This will perform the execution.
     * Notes:
     * - Always log with the provided logger.[error,warning,info,debug].
     * - Do NOT put any user interaction logic UI, etc. inside this method.
     * - callback always has to be called even if error happened.
     *
     * @param {function(Error|null, plugin.PluginResult)} callback - the result callback
     */
    RunWorkflow.prototype.main = function (callback) {
        // Use this to access core, project, result, logger etc from PluginBase.
        const self = this;
        const logger = self.logger;
        const nodeObject = self.activeNode;
        const executionId = makeid();
        const resultId = executionId +'_result.zip';
        const saveDirectory = './OUTPUT/' + executionId;  //TODO how to properly set this and create a temporary directory
        const fs = require('fs');
        const zip = require('zip-a-folder').zip;
        const COMPRESSION_LEVEL = require('zip-a-folder').COMPRESSION_LEVEL;
        const currentConfig = self.getCurrentConfig();
        let consoleOutput = '';
        
        async function ZipFolder (folderPath, output, callback) {
            try {
                await zip(folderPath, output, {compression:COMPRESSION_LEVEL.medium});
                callback(null);
            } catch (e) {
                callback(e);
            }
        }

        fs.mkdir(saveDirectory, err=> {
            if (err) {
                callback(new Error('cannot create execution directory'), this.result);
            } else {
                this.invokePlugin('BuildWorkflow',{pluginConfig:{saveToDir:true,savePath:saveDirectory, exitDepth:1}}, (err, result) => {
                    const runFile = fs.readFileSync(saveDirectory + '/run.sh','utf8');
                    console.log('RUN:',runFile);
                    const child = require('child_process').spawn('./run.sh',[],{
                        cwd: saveDirectory
                    });
                    
                    child.stdout.setEncoding('utf8');
                    child.stdout.on('data', data => {
                        this.sendNotification(JSON.stringify({type:'stdout', message:data}));
                        if (true/*currentConfig.saveOutput*/) {
                            consoleOutput += data;
                        }
                    });
                    child.stderr.setEncoding('utf8');
                    child.stderr.on('data', data => {
                        this.sendNotification(JSON.stringify({type:'stderr', message:data}));
                        if (true/*currentConfig.saveOutput*/) {
                            consoleOutput += data;
                        }
                    });
                    child.on('close', code => {
                        //TODO maybe we want additional message here, but for now it is too much pain
                        // const message = '\u001b[1;41mExecution finished with code: \u001b[34m' + code + '\u001b[0';
                        // this.sendNotification(JSON.stringify({type:'code', message:message}));
                        console.log('CODE:', code);
                        if (code === 0) {
                            self.result.setSuccess(true);
                            if (true/*currentConfig.saveOutput*/){
                                fs.writeFileSync(saveDirectory + '/execution_console_output.log', consoleOutput, 'utf-8');
                            }
                            Q.nfcall(ZipFolder, saveDirectory, './OUTPUT/' + resultId)
                            .then(()=> {
                                return Q.nfcall(fs.rmdir, saveDirectory, {recursive:true});
                            })
                            .then(()=>{
                                return self.blobClient.putFile(resultId, fs.createReadStream('./OUTPUT/' + resultId));
                            })
                            .then((resultHash)=>{
                                self.result.artifacts.push(resultHash);
                                this.sendNotification(JSON.stringify({type:'result', hash:resultHash}));
                                return Q.nfcall(fs.rm, './OUTPUT/' + resultId, {force:true});
                            })
                            .then(()=>{
                                callback(null, self.result);
                            })
                            .catch((err)=>{
                                self.result.setSuccess(false);
                                console.error('Cannot save result directory',err);
                            });
                        } else {
                            callback(null, self.result);
                        }
                    });
                });
            }
        });
    };

    return RunWorkflow;
});
