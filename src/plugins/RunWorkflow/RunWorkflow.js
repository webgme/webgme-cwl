/*globals define*/
/*eslint-env node, browser*/

const { ChildProcess } = require('child_process');

/**
 * Generated by PluginGenerator 2.20.5 from webgme on Wed Apr 27 2022 13:26:17 GMT-0500 (Central Daylight Time).
 * A plugin that inherits from the PluginBase. To see source code documentation about available
 * properties and methods visit %host%/docs/source/PluginBase.html.
 */

define([
    'plugin/PluginConfig',
    'text!./metadata.json',
    'plugin/PluginBase'
], function (
    PluginConfig,
    pluginMetadata,
    PluginBase) {
    'use strict';

    pluginMetadata = JSON.parse(pluginMetadata);

    /**
     * Initializes a new instance of RunWorkflow.
     * @class
     * @augments {PluginBase}
     * @classdesc This class represents the plugin RunWorkflow.
     * @constructor
     */
    function RunWorkflow() {
        // Call base class' constructor.
        PluginBase.call(this);
        this.pluginMetadata = pluginMetadata;
    }

    /**
     * Metadata associated with the plugin. Contains id, name, version, description, icon, configStructure etc.
     * This is also available at the instance at this.pluginMetadata.
     * @type {object}
     */
    RunWorkflow.metadata = pluginMetadata;

    // Prototypical inheritance from PluginBase.
    RunWorkflow.prototype = Object.create(PluginBase.prototype);
    RunWorkflow.prototype.constructor = RunWorkflow;

    function makeid() {
        const length = 16;
        let result = '';
        const characters = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789';
        const charactersLength = characters.length;
        for (let i = 0; i < length; i += 1 ) {
            result += characters.charAt(Math.floor(Math.random() * charactersLength));
        }
       return result;
    };

    /**
     * Main function for the plugin to execute. This will perform the execution.
     * Notes:
     * - Always log with the provided logger.[error,warning,info,debug].
     * - Do NOT put any user interaction logic UI, etc. inside this method.
     * - callback always has to be called even if error happened.
     *
     * @param {function(Error|null, plugin.PluginResult)} callback - the result callback
     */
    RunWorkflow.prototype.main = function (callback) {
        // Use this to access core, project, result, logger etc from PluginBase.
        const self = this;
        const logger = self.logger;
        const nodeObject = self.activeNode;
        const executionId = makeid();
        const resultId = executionId +'_result.zip';
        const saveDirectory = './OUTPUT/' + executionId;  //TODO how to properly set this and create a temporary directory
        const fs = require('fs');
        const zip = require('zip-a-folder').zip;
        const COMPRESSION_LEVEL = require('zip-a-folder').COMPRESSION_LEVEL;
        const currentConfig = self.getCurrentConfig();
        const consoleOutput = '';
        
        async function ZipFolder (folderPath, output, callback) {
            try {
                await zip(folderPath, output, {compression:COMPRESSION_LEVEL.medium});
                callback(null);
            } catch (e) {
                callback(e);
            }
        }

        fs.mkdir(saveDirectory, err=> {
            if (err) {
                callback(new Error('cannot create execution directory'), this.result);
            } else {
                this.invokePlugin('BuildWorkflow',{pluginConfig:{saveToDir:true,savePath:saveDirectory, exitDepth:1}}, (err, result) => {
                    console.log(err);
                    const child = require('child_process').spawn('./run.sh',[],{
                        cwd: saveDirectory
                    });
                    
                    child.stdout.setEncoding('utf8');
                    child.stdout.on('data', data => {
                        this.sendNotification(JSON.stringify({type:'stdout', message:data}));
                        if (currentConfig.saveOutput) {
                            consoleOutput += data;
                        }
                    });
                    child.stderr.setEncoding('utf8');
                    child.stderr.on('data', data => {
                        this.sendNotification(JSON.stringify({type:'stderr', message:data}));
                        if (currentConfig.saveOutput) {
                            consoleOutput += data;
                        }
                    });
                    child.on('close', code => {
                        //TODO maybe we want additional message here, but for now it is too much pain
                        // const message = '\u001b[1;41mExecution finished with code: \u001b[34m' + code + '\u001b[0';
                        // this.sendNotification(JSON.stringify({type:'code', message:message}));
                        console.log('CODE:', code);
                        if (code === 0) {
                            self.result.setSuccess(true);
                            //going through the directory recursively and put the files into an artifact
                            console.log('start');
                            ZipFolder(saveDirectory, './OUTPUT/' + resultId, (err) => {
                                console.log('are we done???', err);
                                fs.rmdir(saveDirectory,{recursive:true}, (err) => {
                                    if (err) {
                                        self.result.setSuccess(false);
                                    }
                                    callback(err, self.result);
                                });
                                callback(null, self.result);
                            });
                            console.log('finished');
                        } else {
                            callback(null, self.result);
                        }
                    });
                });
            }
        });
    };

    return RunWorkflow;
});
