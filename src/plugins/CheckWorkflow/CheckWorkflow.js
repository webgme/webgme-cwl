/*globals define*/
/*eslint-env node, browser*/

/**
 * Generated by PluginGenerator 2.20.5 from webgme on Tue Apr 18 2023 14:31:05 GMT-0500 (Central Daylight Time).
 * A plugin that inherits from the PluginBase. To see source code documentation about available
 * properties and methods visit %host%/docs/source/PluginBase.html.
 */

define([
    'plugin/PluginConfig',
    'text!./metadata.json',
    'plugin/PluginBase'
], function (
    PluginConfig,
    pluginMetadata,
    PluginBase) {
    'use strict';

    pluginMetadata = JSON.parse(pluginMetadata);

    /**
     * Initializes a new instance of CheckWorkflow.
     * @class
     * @augments {PluginBase}
     * @classdesc This class represents the plugin CheckWorkflow.
     * @constructor
     */
    function CheckWorkflow() {
        // Call base class' constructor.
        PluginBase.call(this);
        this.pluginMetadata = pluginMetadata;
        this.createMessage = this.createMessage.bind(this);
        this._getReachableList = this._getReachableList.bind(this);
    }

    /**
     * Metadata associated with the plugin. Contains id, name, version, description, icon, configStructure etc.
     * This is also available at the instance at this.pluginMetadata.
     * @type {object}
     */
    CheckWorkflow.metadata = pluginMetadata;

    // Prototypical inheritance from PluginBase.
    CheckWorkflow.prototype = Object.create(PluginBase.prototype);
    CheckWorkflow.prototype.constructor = CheckWorkflow;

    /**
     * For some of the checking, we require a graph representation...
     */
    CheckWorkflow.prototype.generateSimpleGraph = function () {
        const {core, _nodes, activeNode, META} = this;
        const graph = {v:[],e:[], i:[]};
        core.getChildrenPaths(activeNode).forEach(path => {
            if (core.isInstanceOf(_nodes[path], META['Flow'])) {
                graph.e.push({s:core.getPointerPath(_nodes[path],'src'), d:core.getPointerPath(_nodes[path],'dst')});
            } else {
                graph.v.push(path);
                if (core.isInstanceOf(_nodes[path], META['Input'])) {
                    graph.i.push(path);
                }

            }
        });

        this._graph = graph;
    };

    CheckWorkflow.prototype._isReachableFrom = function (targetPath, startPath) {
        const {_graph} = this;
        const queue = [startPath];
        const reached = [startPath];
        while(queue.length > 0) {
            const current = queue.shift();
            _graph.e.forEach(edge => {
                if(edge.s === current && reached.indexOf(edge.d) === -1) {
                    reached.push(edge.d);
                    queue.push[edge.d];
                }
            });
        }
        
        return reached.indexOf(targetPath) !== -1;
    };

    CheckWorkflow.prototype._getReachableList = function (startPath) {
        const {_graph} = this;
        const queue = [startPath];
        const reached = [startPath];
        while(queue.length > 0) {
            const current = queue.shift();
            _graph.e.forEach(edge => {
                if(edge.s === current && reached.indexOf(edge.d) === -1) {
                    reached.push(edge.d);
                    queue.push[edge.d];
                }
            });
        }
        
        return reached;
    };

    /**
    /* It can be confusing to have multiple nodes with the same name on the same level
    /* and will generally cause a faulty CWL artifacts generation
    */
    CheckWorkflow.prototype.checkUniqueName = function () {
        const {core, _nodes, activeNode, createMessage, result, checkUniqueName} = this;
        const checkSiblings = (siblingPaths => {
            const names = [];
            siblingPaths.forEach(path => {
                const name = core.getAttribute(_nodes[path], 'name');
                if(names.indexOf(name) === -1) {
                    names.push(name);
                    checkUniqueName(core.getChildrenPaths(_nodes[path]));
                } else {
                    createMessage(_nodes[path], 'Elements of a given level of the workflow should have unique names', 'error');
                    result.setSuccess(false);
                }
            });
        });
    };

    /**
     * While not necessarily an issue, if not all input has a default value, then automated
     * execution is in jeopardy and therefore we would like to note the user that they might
     * want to reconsider and give default values to all inputs.
     */
    CheckWorkflow.prototype.checkDefaultInput = function () {
        const {core, activeNode, _nodes, META, createMessage} = this;
        const inputs = [];
        core.getChildrenPaths(activeNode).forEach(path => {
            if (core.isInstanceOf(_nodes[path], META['Input']) && !core.getAttribute(_nodes[path], 'value')) {
                createMessage(_nodes[path], 'Input does not have a set default value which will potentially block automated execution!', 'warning');
            }
        });
    };

    /**
     * While it is again not an error, the user should be warned if there is no input for the
     * workflow as it shows that the reusability of it might be not on 
     */
    CheckWorkflow.prototype.checkInput = function () {
        const {core, activeNode, _nodes, META, createMessage} = this;
        let numOfInputs = 0;
        core.getChildrenPaths(activeNode).forEach(path => {
            if (core.isInstanceOf(_nodes[path], META['Input'])) {
                numOfInputs += 1;
            }
        });

        if (numOfInputs === 0) {
            createMessage(activeNode, 'There is no input in the workflow, you might want to check it as this limits its reusability!', 'warning');
        }
    };

    /**
     * While it is not an error, the user should be warned if there is no output for the
     * workflow as it could show that there is no way of checking whether any  
     */
    CheckWorkflow.prototype.checkOutput = function () {
        const {core, activeNode, _nodes, META, createMessage} = this;
        let numOfOutputs = 0;
        core.getChildrenPaths(activeNode).forEach(path => {
            if (core.isInstanceOf(_nodes[path], META['Output'])) {
                numOfOutputs += 1;
            }
        });

        if (numOfOutputs === 0) {
            createMessage(activeNode, 'There is no output in the workflow, you might want to check it this makes its verification questionable!', 'warning');
        }
    };

    /**
     * Having unreachable elements in a workflow means that it is not formed to its potential.
     * While it only warrants a warning, all such elements should be either fed with intput flow
     * or removed from the workflow.
     * 
     */
    CheckWorkflow.prototype.checkUnreachable = function () {
        const {_graph, createMessage, _nodes, _getReachableList} = this;
        const unreachables = [];
        const reachables = [];
        _graph.i.forEach(inputVertexPath => {
            reachables.push(..._getReachableList(inputVertexPath));
        });

        _graph.v.forEach(vertexPath => {
            if (reachables.indexOf(vertexPath) === -1) {
                unreachables.push(vertexPath);
            }
        });

        unreachables.forEach(unreachablePath => {
            createMessage(_nodes[unreachablePath], 'The element cannot be reached from any inputs which means it is processing without context!', 'warning');
        })
    }

    /**
     * 
     * Having default value for a file input without location will cause crash in the generation so 
     * it should be handled as a violation
     */
    CheckWorkflow.prototype.checkNoDefaultLocation = function () {
        const {core, activeNode, _nodes, META, createMessage} = this;
        let inputWithDefaultAndNoLocation = false;
        core.getChildrenPaths(activeNode).forEach(path => {
            if (core.isInstanceOf(_nodes[path], META['FileInput'])) {
                if(core.getAttribute(_nodes[path], 'value') && !core.getAttribute(_nodes[path], 'location')) {
                    inputWithDefaultAndNoLocation = true;
                    createMessage(_nodes[path], 'This file input has a default content without a default filename which will cause build error!', 'error');
                }
            }
        });

        if (inputWithDefaultAndNoLocation) {
            result.setSuccess(false);
        }
    };

    CheckWorkflow.prototype.getChecks = function () {
        const members = Object.getOwnPropertyNames(this.__proto__);
        const checks = [];

        members.forEach(member => {
            if( member.indexOf('check') === 0) {
                checks.push(member);
            }
        });

        return checks;
    };

    /**
     * Main function for the plugin to execute. This will perform the execution.
     * Notes:
     * - Always log with the provided logger.[error,warning,info,debug].
     * - Do NOT put any user interaction logic UI, etc. inside this method.
     * - callback always has to be called even if error happened.
     *
     * @param {function(Error|null, plugin.PluginResult)} callback - the result callback
     */
    CheckWorkflow.prototype.main = function (callback) {
        const checks = this.getChecks();
        const {result, activeNode} = this;

        result.setSuccess(true);

        this.loadNodeMap(activeNode)
        .then(map => {
            this._nodes = map;
            this.generateSimpleGraph();
            checks.forEach(check => {
                this[check]();
            });
            callback(null, result);
        })
        .catch(err => {
            result.setSuccess(false);
            callback(err, result);
        });
    };

    return CheckWorkflow;
});
