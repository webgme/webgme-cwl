/*globals define*/
/*eslint-env node, browser*/

/**
 * Generated by PluginGenerator 2.20.5 from webgme on Tue Jan 17 2023 23:31:37 GMT-0600 (Central Standard Time).
 * A plugin that inherits from the PluginBase. To see source code documentation about available
 * properties and methods visit %host%/docs/source/PluginBase.html.
 */

define([
    'plugin/PluginConfig',
    'text!./metadata.json',
    'plugin/PluginBase'
], function (
    PluginConfig,
    pluginMetadata,
    PluginBase) {
    'use strict';

    pluginMetadata = JSON.parse(pluginMetadata);

    /**
     * Initializes a new instance of ExportWorkflow.
     * @class
     * @augments {PluginBase}
     * @classdesc This class represents the plugin ExportWorkflow.
     * @constructor
     */
    function ExportWorkflow() {
        // Call base class' constructor.
        PluginBase.call(this);
        this.pluginMetadata = pluginMetadata;
    }

    /**
     * Metadata associated with the plugin. Contains id, name, version, description, icon, configStructure etc.
     * This is also available at the instance at this.pluginMetadata.
     * @type {object}
     */
    ExportWorkflow.metadata = pluginMetadata;

    // Prototypical inheritance from PluginBase.
    ExportWorkflow.prototype = Object.create(PluginBase.prototype);
    ExportWorkflow.prototype.constructor = ExportWorkflow;

    /**
     * Main function for the plugin to execute. This will perform the execution.
     * Notes:
     * - Always log with the provided logger.[error,warning,info,debug].
     * - Do NOT put any user interaction logic UI, etc. inside this method.
     * - callback always has to be called even if error happened.
     *
     * @param {function(Error|null, plugin.PluginResult)} callback - the result callback
     */
    ExportWorkflow.prototype.main = function (callback) {
        const {activeNode, core, logger, result} = this;
        
        this.loadNodeMap(activeNode)
        .then(nodes => {
            this._nodes = nodes;
            const CWF = this.workflowToJSON(activeNode);

            this.createMessage(
                activeNode, 
                JSON.stringify(CWF, null, 2), 
                'debug'
            );

            return this.addFile(
                core.getAttribute(activeNode, 'name') + '.CWF', 
                JSON.stringify(CWF, null, 2)
            );
        })
        .then(fileHash => {
            result.setSuccess(true);
            callback(null, result);
        })
        .catch(err => {
            logger.error(err.stack);
            callback(err, result);
        });
    };

    ExportWorkflow.prototype.workflowToJSON = function (wfNode) {
        const {core, logger, META} = this;
        const result = {
            guid: core.getGuid(wfNode), 
            attributes:this.attributesToJSON(wfNode), 
            registry:this.registryToJSON(wfNode),
            steps:{},
            subs:{},
            ports:{},
            flows:{}
        };
        const childrenPaths = core.getChildrenPaths(wfNode);

        childrenPaths.forEach(child => {
            const node = this._nodes[child];
            if(core.isInstanceOf(node, META['Step'])) {
                result.steps[core.getRelid(node)] = this.stepToJSON(node);
            } else if (core.isInstanceOf(node, META['Workflow'])) {
                result.subs[core.getRelid(node)] = this.workflowToJSON(node);
            } else if (core.isInstanceOf(node, META['Input']) ||
                core.isInstanceOf(node, META['Output'])) {
                result.ports[core.getRelid(node)] = this.portToJSON(node);
            } else if (core.isInstanceOf(node, META['Flow'])) {
                result.flows[core.getRelid(node)] = this.flowToJSON(node);
            }
        });

        return result;
    };

    ExportWorkflow.prototype.stepToJSON = function (node) {
        const {core, META} = this;
        const result = {
            guid: core.getGuid(node),
            type: this.getNodeType(node),
            attributes: this.attributesToJSON(node),
            registry: this.registryToJSON(node),
            ports:{}
        };
        core.getChildrenPaths(node).forEach(childPath => {
            const child = this._nodes[childPath];
            if (core.isInstanceOf(child, META['Input']) ||
                core.isInstanceOf(child, META['Output'])) {
                result.ports[core.getRelid(child)] = this.portToJSON(child);
            }
        });

        return result;
    };

    ExportWorkflow.prototype.portToJSON = function (node) {
        const {core} = this;

        return {
            guid: core.getGuid(node),
            type: this.getNodeType(node),
            attributes: this.attributesToJSON(node),
            registry: this.registryToJSON(node)
        }
    };

    ExportWorkflow.prototype.attributesToJSON = function (node) {
        const {core} = this;
        const result = {};
        core.getOwnAttributeNames(node).forEach(name => {
            result[name] = core.getAttribute(node, name);
        });
        return result;
    };

    ExportWorkflow.prototype.registryToJSON = function (node) {
        const {core} = this;
        const result = {};
        core.getOwnRegistryNames(node).forEach(name => {
            result[name] = core.getRegistry(node, name);
        });
        return result;
    };

    ExportWorkflow.prototype.flowToJSON = function (node) {
        const {core} = this;
        return {
            guid: core.getGuid(node),
            type: this.getNodeType(node),
            src: this.getOwnPath(this._nodes[core.getPointerPath(node,'src')]),
            dst: this.getOwnPath(this._nodes[core.getPointerPath(node,'dst')]),
            attributes: this.attributesToJSON(node),
            registry: this.registryToJSON(node)
        };
    };

    ExportWorkflow.prototype.getOwnPath = function (node) {
        const {activeNode, core} = this;
        const mainPath = core.getPath(activeNode);
        const fullPath = core.getPath(node);
        const regex = new RegExp('^'+mainPath,'g');
        return fullPath.replace(regex, '');
    };

    ExportWorkflow.prototype.getNodeType = function (node) {
        const {core} = this;
        const typeNode = core.getMetaType(node);

        return {
            guid: core.getGuid(typeNode),
            name: core.getAttribute(typeNode, 'name')
        };
    };
    
    return ExportWorkflow;
});
