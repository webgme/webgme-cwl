/*globals define*/
/*eslint-env node, browser*/

/**
 * Generated by PluginGenerator 2.20.5 from webgme on Wed Aug 03 2022 22:39:37 GMT-0500 (Central Daylight Time).
 * A plugin that inherits from the PluginBase. To see source code documentation about available
 * properties and methods visit %host%/docs/source/PluginBase.html.
 */

 define([
    'plugin/PluginConfig',
    'text!./metadata.json',
    'plugin/PluginBase'
], function (
    PluginConfig,
    pluginMetadata,
    PluginBase) {
    'use strict';

    pluginMetadata = JSON.parse(pluginMetadata);

    /**
     * Initializes a new instance of ReleaseWorkflow.
     * @class
     * @augments {PluginBase}
     * @classdesc This class represents the plugin ReleaseWorkflow.
     * @constructor
     */
    function ReleaseWorkflow() {
        // Call base class' constructor.
        PluginBase.call(this);
        this.pluginMetadata = pluginMetadata;
    }

    function makeid() {
        const length = 16;
        let result = '';
        const characters = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789';
        const charactersLength = characters.length;
        for (let i = 0; i < length; i += 1 ) {
            result += characters.charAt(Math.floor(Math.random() * charactersLength));
        }
       return 'rel_' + result;
    }

    /**
     * Metadata associated with the plugin. Contains id, name, version, description, icon, configStructure etc.
     * This is also available at the instance at this.pluginMetadata.
     * @type {object}
     */
    ReleaseWorkflow.metadata = pluginMetadata;

    // Prototypical inheritance from PluginBase.
    ReleaseWorkflow.prototype = Object.create(PluginBase.prototype);
    ReleaseWorkflow.prototype.constructor = ReleaseWorkflow;

    /**
     * Main function for the plugin to execute. This will perform the execution.
     * Notes:
     * - Always log with the provided logger.[error,warning,info,debug].
     * - Do NOT put any user interaction logic UI, etc. inside this method.
     * - callback always has to be called even if error happened.
     *
     * @param {function(Error|null, plugin.PluginResult)} callback - the result callback
     */
    ReleaseWorkflow.prototype.main = async function (callback) {
        const self = this;
        const core = this.core;
        const logger = self.logger;
        const nodeObject = self.activeNode;
        const executionId = makeid();
        // const executionId = 'release';
        const resultId = executionId +'_result.zip';
        const saveDirectory = './OUTPUT/' + executionId;  //TODO how to properly set this and create a temporary directory
        const fs = require('fs');
        const zip = require('zip-a-folder').zip;
        const COMPRESSION_LEVEL = require('zip-a-folder').COMPRESSION_LEVEL;
        const currentConfig = self.getCurrentConfig();
        const serialization = requireJS('common/util/serialization');
        const previousReleasePDP = core.getAttribute(nodeObject,'pdpId') || '98df2486-153f-4ce0-93bf-c06cdd94657a_1';
        const previousVersion = core.getAttribute('version') || 0;
        const previousIndexPDP = previousReleasePDP.split('_')[1]; //TODO proper index needed from get status or sg


        core.setAttribute(nodeObject, 'pdpId', previousReleasePDP.split('_')[0] + '_' + (Number(previousIndexPDP) + 1));
        core.setAttribute(nodeObject, 'version', Number(previousVersion) + 1);
        await this.save('releasing workflow');

        const releaseMetadata = {
            Project: {
                Id: this.projectId,
                Commit: this.currentHash,
                Name: this.projectName,
                Branch: this.branchName
            },
            InputDependency: this.getInputDependency(),
            Previous: {
                version: previousVersion,
                PDPId: previousReleasePDP
            }
        };

        async function ZipFolder (folderPath, output, callback) {
            try {
                await zip(folderPath, output, {compression:COMPRESSION_LEVEL.medium});
                callback(null);
            } catch (e) {
                callback(e);
            }
        }

        try {
            fs.mkdirSync(saveDirectory);
            fs.mkdirSync(saveDirectory+'/cwl');
            fs.mkdirSync(saveDirectory+'/cwl/cwl');
            fs.mkdirSync(saveDirectory+'/cwl/ds');
            this.invokePlugin('BuildWorkflow',{pluginConfig:{saveToDir:true,savePath:saveDirectory+'/cwl/cwl', exitDepth:1}}, (err, result) => {
                if (err) {
                    callback(err);
                } else {
                    serialization.exportProjectToFile(this.project, this.blobClient, {commitHash:this.commitHash, outName:'released', withAssets:true}, (err, result) => {
                        if(err) {
                            logger.error(err);
                            return callback(err);
                        }
                        logger.error('saved project', result);
                        const outproject = fs.createWriteStream(saveDirectory+'/cwl/ds/released.webgmex');
                        
                        outproject.on('error', function (err) {
                            logger.error(err);
                            return callback(new Error('cannot export project:', err));
                        });
                          
                        outproject.on('finish', function () {
                            fs.writeFileSync(saveDirectory+'/metadata.json', JSON.stringify(releaseMetadata));
                            fs.writeFileSync(saveDirectory+'/release.sh', 'java -jar ~/pdp_cli/pdp_cli_secret.jar push -d ./cwl -p 98df2486-153f-4ce0-93bf-c06cdd94657a -f ./metadata.json');
                            fs.chmodSync(saveDirectory+'/release.sh',0o777);
                            const spawn = require('child_process').spawnSync;
                            // const returnVal = spawn('java', ['-jar', '~/pdp_cli/pdp_cli_secret.jar','-p', '98df2486-153f-4ce0-93bf-c06cdd94657a', '-d', './cwl/'],{cwd:saveDirectory});
                            const returnVal = spawn('./release.sh', [],{cwd:saveDirectory});
                            logger.info(returnVal.stdout);
                            logger.error(returnVal.stderr);
                            logger.info(returnVal.status);
                            if(returnVal.status !== 0) {
                                return callback(new Error('failed to push data to PDP :' + returnVal.stderr));
                            }
        
                            fs.rmSync(saveDirectory, { recursive: true });
                            console.info('workflow released');
                            self.result.setSuccess(true);
                            return callback(null, self.result);
                        });
                        
                        this.blobClient.getStreamObject(result.hash, outproject);
                    });
                }
            });
        } catch (e) {
            logger.error(e);
            return callback(e);
        }
        
    };

    ReleaseWorkflow.prototype.getInputDependency = async () => {
        const self = this;
        const logger = self.logger;
        const nodeObject = self.activeNode;
        const core = self.core;
        //TODO: we need to refresh the metamodel so that we look for actual data input steps...
        const pullGuid = '9bc917d8-b5e3-3cd3-e17e-650bd3c2e695';
        const isNodePull = node => {
            let parent = node;
            while(parent !== null) {
                if (core.getGuid(parent) === pullGuid) {
                    return core.getAttribute(node, 'value');
                }
                parent = core.getParent(parent);
            }
            return null;
        };
        const nodes = await core.loadSubTree(nodeObject);

        
    };

    return ReleaseWorkflow;
});
