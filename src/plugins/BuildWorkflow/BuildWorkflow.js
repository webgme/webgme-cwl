/*globals define*/
/*eslint-env node, browser*/

/**
 * Generated by PluginGenerator 2.20.5 from webgme on Thu Jan 20 2022 13:06:45 GMT-0600 (Central Standard Time).
 * A plugin that inherits from the PluginBase. To see source code documentation about available
 * properties and methods visit %host%/docs/source/PluginBase.html.
 */

 define([
    'plugin/PluginConfig',
    'text!./metadata.json',
    'plugin/PluginBase',
    'webgme-cwl/graph',
    'webgme-cwl/naming',
    'webgme-cwl/step',
    'webgme-json/jsonFunctions',
    'webgme-cwl/Steps/index',
    'webgme-cwl/Workflow/index',
    'q',
    'lodash'
], function (
    PluginConfig,
    pluginMetadata,
    PluginBase,
    Graph,
    NAMING,
    StepHelper,
    JSONFunctions,
    Steps,
    Workflow,
    Q,
    _) {
    'use strict';

    pluginMetadata = JSON.parse(pluginMetadata);

    /**
     * Initializes a new instance of BuildWorkflow.
     * @class
     * @augments {PluginBase}
     * @classdesc This class represents the plugin BuildWorkflow.
     * @constructor
     */
    function BuildWorkflow() {
        // Call base class' constructor.
        PluginBase.call(this);
        this.pluginMetadata = pluginMetadata;
    }

    /**
     * Metadata associated with the plugin. Contains id, name, version, description, icon, configStructure etc.
     * This is also available at the instance at this.pluginMetadata.
     * @type {object}
     */
    BuildWorkflow.metadata = pluginMetadata;

    // Prototypical inheritance from PluginBase.
    BuildWorkflow.prototype = Object.create(PluginBase.prototype);
    BuildWorkflow.prototype.constructor = BuildWorkflow;

    /**
     * Main function for the plugin to execute. This will perform the execution.
     * Notes:
     * - Always log with the provided logger.[error,warning,info,debug].
     * - Do NOT put any user interaction logic UI, etc. inside this method.
     * - callback always has to be called even if error happened.
     *
     * @param {function(Error|null, plugin.PluginResult)} callback - the result callback
     */
    BuildWorkflow.prototype.main = function (callback) {
        // Use this to access core, project, result, logger etc from PluginBase.
        const activeNode = this.activeNode;
        const core = this.core;
        const META = this.META;
        const activeNodePath = core.getPath(activeNode);
        const currentConfig = this.getCurrentConfig();
        const saveDirectory = currentConfig.saveToDir ? currentConfig.savePath : null;
        this.core.loadSubTree(activeNode)
        .then(allNodes => {
            this._nodes = {};
            allNodes.forEach(node => {
                this._nodes[core.getPath(node)] = node;
            });
            const files = {};
            const artifacts = [];
            files[core.getAttribute(activeNode, 'name') + '.cwl.json'] = this.processWorkflow(activeNode, files, artifacts);
            const mainContext = this.getWorkflowContext(activeNode);
            const mainInputs = [];
            mainContext.inputs.forEach(input => {
                mainInputs.push(core.getAttribute(this._nodes[input], 'name'));
            });
            const defaultInfo = {};
            artifacts.forEach(artifact => {
                if(mainInputs.indexOf(artifact.input) !== -1) {
                    defaultInfo[artifact.input] = artifact.name;
                }
            });
            files['README.md'] = Workflow.getReadMeContent(core, META, activeNode, this._nodes, defaultInfo);

            return this.generateArtifact(files, artifacts, mainInputs, saveDirectory);
        })
        .then((/*artifactHash*/) => {
            this.result.setSuccess(true);
            callback(null, this.result);
        })
        .catch(err => {
            this.result.setSuccess(false);
            callback(err, null);
        });        
    };

    BuildWorkflow.prototype.processWorkflow = function(workflowNode, files, artifacts) {
        const context = this.getWorkflowContext(workflowNode);
        const cwlContent = {
            cwlVersion: 'v1.1',
            class: 'Workflow',
            inputs:{},
            outputs:{},
            steps:{},
            requirements:{
                SubworkflowFeatureRequirement:{},
                InitialWorkDirRequirement:{
                    listing:[]
                }
            },
            arguments:[
                {
                  "shellQuote": false,
                  "valueFrom": "mkdir download\ndownload_pdp pull -d ./download/ -i 364"
                }
            ]
        };

        //Inputs
        context.inputs.forEach(input => {
            Steps.processInput(context.core, context.META, context.nodes[input], cwlContent, artifacts);
        });
        delete cwlContent.arguments;

        //Steps and sub-workflows
        context.steps.forEach(step => {
            const stepNode = context.nodes[step];
            const fileName = context.core.getGuid(stepNode) + '_step.cwl.json';
            files[fileName] = this.processStep(stepNode);
            cwlContent.steps[context.core.getAttribute(stepNode, 'name')] = {
                run: fileName,
                in:{},
                out:[]
            };
        });
        context.subworkflows.forEach(swf => {
            const swfNode = context.nodes[swf];
            const fileName = context.core.getGuid(swfNode) + '_swf.cwl.json';
            files[fileName] = this.processWorkflow(swfNode, files);
            cwlContent.steps[context.core.getAttribute(swfNode, 'name')] = {
                run: fileName,
                in:{},
                out:[]
            };
        });

        //Finally: flows
        context.flows.forEach(flow => {
            if (flow.dstHost) {
                cwlContent.steps[flow.dstHost].in[flow.dst] = flow.srcHost ? flow.srcHost + '/' + flow.src : flow.src;
            } else {
                cwlContent.outputs[flow.dst] = {
                    type: flow.type,
                    outputSource: flow.srcHost ? flow.srcHost + '/' + flow.src : flow.src 
                }
            }
            if(flow.srcHost && cwlContent.steps[flow.srcHost].out.indexOf(flow.src) === -1) {
                cwlContent.steps[flow.srcHost].out.push(flow.src);
            }
        });

        return cwlContent;
    };

    BuildWorkflow.prototype.getWorkflowContext = function(workflowNode) {
        const context = {
            inputs:[], 
            outputs:[], 
            steps:[], 
            subworkflows:[],
            flows:[], 
            core: this.core, 
            META: this.META, 
            nodes: this._nodes
        };

        const myPath = this.core.getPath(workflowNode);
        this.core.getChildrenPaths(workflowNode).forEach(childPath => {
            if (this.core.isInstanceOf(this._nodes[childPath], this.META['Input'])) {
                context.inputs.push(childPath);
            } else if (this.core.isInstanceOf(this._nodes[childPath], this.META['Output'])) {
                context.outputs.push(childPath);
            } else if (this.core.isInstanceOf(this._nodes[childPath], this.META['Step'])) {
                context.steps.push(childPath);
            } else if (this.core.isInstanceOf(this._nodes[childPath], this.META['Workflow'])) {
                context.subworkflows.push(childPath);
            } else if (this.core.isInstanceOf(this._nodes[childPath], this.META['Flow'])) {
                //TODO this needs to be more sophisticated when it comes to scatter and merge patterns
                const element = {path: childPath};
                const srcHostNode = this.core.getParent(
                    this._nodes[this.core.getPointerPath(this._nodes[childPath], 'src')]);
                const dstHostNode = this.core.getParent(
                    this._nodes[this.core.getPointerPath(this._nodes[childPath], 'dst')]);
                element.srcHost = this.core.getPath(srcHostNode) === myPath ? 
                    null : this.core.getAttribute(srcHostNode, 'name');
                element.src = this.core.getAttribute(
                    this._nodes[this.core.getPointerPath(this._nodes[childPath], 'src')], 'name');
                element.dstHost = this.core.getPath(dstHostNode) === myPath ? 
                    null : this.core.getAttribute(dstHostNode, 'name');
                element.dst = this.core.getAttribute(
                    this._nodes[this.core.getPointerPath(this._nodes[childPath], 'dst')], 'name');
                
                if(!element.dstHost) {
                    if(this.core.isInstanceOf(
                        this._nodes[this.core.getPointerPath(this._nodes[childPath], 'dst')],
                        this.META['FileOutput'])) {
                            element.type = 'File';
                        }
                    else if(this.core.isInstanceOf(
                        this._nodes[this.core.getPointerPath(this._nodes[childPath], 'dst')],
                        this.META['DirectoryOutput'])) {
                            element.type = 'Directory';
                        }
                }
                context.flows.push(element);
            }
        });

        return context;
    };

    BuildWorkflow.prototype.getStepContext = function(stepNode) {
        const context = {
            inputs:[], 
            outputs:[], 
            core: this.core, 
            META: this.META, 
            nodes: this._nodes
        };
        
        context.core.getChildrenPaths(stepNode).forEach(childPath => {
            if (context.core.isInstanceOf(this._nodes[childPath], this.META['Input'])) {
                context.inputs.push(childPath);
            } else if (context.core.isInstanceOf(this._nodes[childPath], this.META['Output'])) {
                context.outputs.push(childPath);
            } 
        });

        return context;
    };

    BuildWorkflow.prototype.processStep = function(stepNode) {
        const context = this.getStepContext(stepNode);
        const stepName = context.core.getAttribute(context.core.getMetaType(stepNode), 'name');
        return Steps[stepName](stepNode, context);
    };

    BuildWorkflow.prototype.generateArtifact = function(files, artifacts, mainInputs, saveDirectory) {
        // console.log('SAVE?',saveDirectory);
        const deferred = Q.defer();
        const fileNames = Object.keys(files);
        let fs = null;
        const artifactName = this.core.getAttribute(this.activeNode, 'name'); 
        const artifact = this.blobClient.createArtifact(artifactName);
        const promises = [];
        const saveToDisc = (path, content) => {
            const defd = Q.defer();
            const options = {};
            // console.log('WO:', path);
            fs.writeFile(path, content, options, err => {
                if (err) {
                    // console.log('WO-err:', path);
                    defd.reject(err);
                } else {
                    // console.log('WO-done:', path);
                    defd.resolve(null);
                }
            });
            return defd.promise;
        };

        if (saveDirectory) {
            fs = require('fs');
            fileNames.forEach(fileName => {
                if (fileName === 'README.md') {
                    promises.push(saveToDisc(fileName, files[fileName]));
                } else {
                    promises.push(saveToDisc(fileName, JSON.stringify(files[fileName], null, 2)));
                }
            });
            artifacts.forEach(fileinfo => {
                promises.push(saveToDisc(fileinfo.name, fileinfo.content));
            });
        } else {
            fileNames.forEach(fileName => {
                if (fileName === 'README.md') {
                    promises.push(artifact.addFile(fileName, files[fileName]));
                } else {
                    promises.push(artifact.addFile(fileName, JSON.stringify(files[fileName], null, 2)));
                }
            });
            artifacts.forEach(fileinfo => {
                promises.push(artifact.addFile(fileinfo.name, fileinfo.content));
            });
        }

        Q.all(promises)
        .then(results => {
            if(saveDirectory) {
                return Q(null);
            } else {
                return artifact.save();
            }
        })
        .then(artifactHash => {
            if (artifactHash) {
                this.result.addArtifact(artifactHash);
            }
            deferred.resolve(artifactHash);
        })
        .catch(deferred.reject);

        return deferred.promise;
    };

    return BuildWorkflow;
});
