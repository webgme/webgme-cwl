/*globals define*/
/*eslint-env node, browser*/

/**
 * Generated by PluginGenerator 2.20.5 from webgme on Thu Jan 20 2022 13:06:45 GMT-0600 (Central Standard Time).
 * A plugin that inherits from the PluginBase. To see source code documentation about available
 * properties and methods visit %host%/docs/source/PluginBase.html.
 */

define([
    'plugin/PluginConfig',
    'text!./metadata.json',
    'plugin/PluginBase',
    'webgme-cwl/graph',
    'q'
], function (
    PluginConfig,
    pluginMetadata,
    PluginBase,
    Graph,
    Q) {
    'use strict';

    pluginMetadata = JSON.parse(pluginMetadata);

    /**
     * Initializes a new instance of BuildWorkflow.
     * @class
     * @augments {PluginBase}
     * @classdesc This class represents the plugin BuildWorkflow.
     * @constructor
     */
    function BuildWorkflow() {
        // Call base class' constructor.
        PluginBase.call(this);
        this.pluginMetadata = pluginMetadata;
    }

    /**
     * Metadata associated with the plugin. Contains id, name, version, description, icon, configStructure etc.
     * This is also available at the instance at this.pluginMetadata.
     * @type {object}
     */
    BuildWorkflow.metadata = pluginMetadata;

    // Prototypical inheritance from PluginBase.
    BuildWorkflow.prototype = Object.create(PluginBase.prototype);
    BuildWorkflow.prototype.constructor = BuildWorkflow;

    /**
     * Main function for the plugin to execute. This will perform the execution.
     * Notes:
     * - Always log with the provided logger.[error,warning,info,debug].
     * - Do NOT put any user interaction logic UI, etc. inside this method.
     * - callback always has to be called even if error happened.
     *
     * @param {function(Error|null, plugin.PluginResult)} callback - the result callback
     */
    BuildWorkflow.prototype.main = function (callback) {
        // Use this to access core, project, result, logger etc from PluginBase.
        const activeNode = this.activeNode;
        const core = this.core;
        const META = this.META;
        const activeNodePath = core.getPath(activeNode);
        const nodes = {};
        const allNodes = {};
        const isSimpleStep = false;

        this.core.loadSubTree(activeNode)
        .then(allNodes_ => {
            const directChildrenPaths = core.getChildrenPaths(activeNode);
            allNodes_.forEach(node => {
                const path = core.getPath(node);
                allNodes[path] = node;
                if (directChildrenPaths.indexOf(path) !== -1 ||
                directChildrenPaths.indexOf(core.getPath(core.getParent(node))) !== -1) {
                    if (core.isInstanceOf(node, META['Step'])) {
                        isSimpleStep = false;
                    }
                    nodes[path] = node;
                }
            });

            if (isSimpleStep) {
                return this.buildSimpleStep(allNodes);
            } else {
                return this.buildCompositeStep(nodes);
            }
        })
        .then(partialResult => {
            if (isSimpleStep) {
                return partialResult;
            } else {
                //we need to order steps and create the upper level step description
                const graph = new Graph(core, nodes, META);
                if (!graph.isDAG()) {
                    throw new Error('cannot work with flows having loops!');
                } 

                stepOrder = graph.getStepOrder();

        })
        .then(result => {
            if (this.callDepth > 0) {
                //invoked - we just create a message and put the result there
                this.createMessage(this.activeNode, JSON.stringify(result));
                return Q(null);
            } else {
                //we are the uppermost step, so we need to make all the artifacts...
                return this.createArtifact(result);
            }
        })
        .then(artifactHash => {
            if(artifactHash) {
                this.result.addArtifact(artifactHash);
            }
            this.result.setSuccess(true);
            callback(null, this.result);
        })
        .catch(err => {
            this.result.setSuccess(false);
            callback(err, null);
        });        
    };

    BuildWorkflow.prototype.buildSimpleStep = function(nodes) {
        const node = this.activeNode;
        const code = eval(core.getAttribute(node, 'exportCode') || '() => {return {}; }');
        const template = core.getAttribute(node, 'exportTemplate') || null;

        const returnValue = code(this.core, nodes, this.META, template, this.logger.fork('Step[' + core.getAttribute(node, 'name') + ']'));
        return Q(returnValue);
    };

    BuildWorkflow.prototype.buildCompositeStep = function(nodes) {
        const deferred = Q.defer();
        const core = this.core;
        const META = this.META;
        const subSteps = [];
        const returnValue = {subSteps:{}};
        const promises = [];

        core.getChildrenPaths(activeNode).forEach(path => {
            if (core.isInstanceOf(nodes[path], META['Step'])) {
                subSteps.push(core.getAttribute(nodes[path], 'name'));
                const context = {namespace:'', activeNode:nodes[path], activeSelection:[], pluginConfig:{}};
                promises.push(this.invokePlugin(this.metadata.id, context));
            }
        });

        Q.all(promises)
        .then(results => {
            results.forEach(result, index => {
                returnValue.subSteps[subSteps[index]] = JSON.parse(result.getCommitMessages()[0].message);
            });
            deferred.resolve(returnValue);
        })
        .catch(deferred.reject);

        return deferred.promise;
    };

    BuildWorkflow.prototype.createArtifact = function(cwlObject) {
        const artifact = {};

        return null;
    };

    return BuildWorkflow;
});
