/*globals define*/
/*eslint-env node, browser*/

/**
 * Generated by PluginGenerator 2.20.5 from webgme on Thu Jan 20 2022 13:06:45 GMT-0600 (Central Standard Time).
 * A plugin that inherits from the PluginBase. To see source code documentation about available
 * properties and methods visit %host%/docs/source/PluginBase.html.
 */

 define([
    'plugin/PluginConfig',
    'text!./metadata.json',
    'plugin/PluginBase',
    'webgme-cwl/graph',
    'webgme-cwl/naming',
    'webgme-cwl/Steps/index',
    'webgme-cwl/Workflow/index',
    'q',
    'lodash'
], function (
    PluginConfig,
    pluginMetadata,
    PluginBase,
    Graph,
    NAMING,
    Steps,
    Workflow,
    Q,
    _) {
    'use strict';

    pluginMetadata = JSON.parse(pluginMetadata);

    /**
     * Initializes a new instance of BuildWorkflow.
     * @class
     * @augments {PluginBase}
     * @classdesc This class represents the plugin BuildWorkflow.
     * @constructor
     */
    function BuildWorkflow() {
        // Call base class' constructor.
        PluginBase.call(this);
        this.pluginMetadata = pluginMetadata;
    }

    /**
     * Metadata associated with the plugin. Contains id, name, version, description, icon, configStructure etc.
     * This is also available at the instance at this.pluginMetadata.
     * @type {object}
     */
    BuildWorkflow.metadata = pluginMetadata;

    // Prototypical inheritance from PluginBase.
    BuildWorkflow.prototype = Object.create(PluginBase.prototype);
    BuildWorkflow.prototype.constructor = BuildWorkflow;

    /**
     * Main function for the plugin to execute. This will perform the execution.
     * Notes:
     * - Always log with the provided logger.[error,warning,info,debug].
     * - Do NOT put any user interaction logic UI, etc. inside this method.
     * - callback always has to be called even if error happened.
     *
     * @param {function(Error|null, plugin.PluginResult)} callback - the result callback
     */
    BuildWorkflow.prototype.main = function (callback) {
        // Use this to access core, project, result, logger etc from PluginBase.
        const activeNode = this.activeNode;
        const core = this.core;
        const META = this.META;
        const activeNodePath = core.getPath(activeNode);
        const currentConfig = this.getCurrentConfig();
        const saveDirectory = currentConfig.saveToDir ? currentConfig.savePath : null;
        this.core.loadSubTree(activeNode)
        .then(allNodes => {
            this._nodes = {};
            allNodes.forEach(node => {
                this._nodes[core.getPath(node)] = node;
            });
            const files = {};
            const artifacts = [];
            const mainFileName = core.getAttribute(activeNode, 'name') + '.cwl.json'
            files[mainFileName] = this.processWorkflow(activeNode, files, artifacts);
            const mainContext = this.getWorkflowContext(activeNode);
            const mainInputs = [];
            mainContext.inputs.forEach(input => {
                mainInputs.push(core.getAttribute(this._nodes[input], 'name'));
            });
            const defaultInfo = {};
            const runDefaults = [];
            artifacts.forEach(artifact => {
                if(mainInputs.indexOf(artifact.input) !== -1 && artifact.name) {
                    defaultInfo[artifact.input] = artifact.name;
                    runDefaults.push({name: artifact.input, value: artifact.name});
                }
            });
            console.log(mainInputs);
            console.log(defaultInfo);
            console.log(runDefaults);
            files['README.md'] = Workflow.getReadMeContent(core, META, activeNode, this._nodes, defaultInfo);
            files['run.sh'] = Workflow.getRunScriptContent(mainFileName, runDefaults);

            return this.generateArtifact(files, artifacts, mainInputs, saveDirectory);
        })
        .then((/*artifactHash*/) => {
            this.result.setSuccess(true);
            callback(null, this.result);
        })
        .catch(err => {
            this.result.setSuccess(false);
            callback(err, null);
        });        
    };

    BuildWorkflow.prototype.processWorkflow = function(workflowNode, files, artifacts) {
        const context = this.getWorkflowContext(workflowNode);
        const cwlContent = {
            cwlVersion: 'v1.1',
            class: 'Workflow',
            inputs:{},
            outputs:{},
            steps:{},
            requirements:{
                InlineJavascriptRequirement:{},
                SubworkflowFeatureRequirement:{}
            },
            arguments:[{}]
        };

        //Inputs
        context.inputs.forEach(input => {
            Steps.processInput(context.core, context.META, context.nodes[input], cwlContent, artifacts);
        });

        delete cwlContent.arguments;

        //Steps and sub-workflows
        context.steps.forEach(step => {
            const stepNode = context.nodes[step];
            const fileName = context.core.getGuid(stepNode) + '_step.cwl.json';
            files[fileName] = this.processStep(stepNode, artifacts);
            cwlContent.steps[context.core.getAttribute(stepNode, 'name')] = {
                run: fileName,
                in:{},
                out:[]
            };
        });
        context.subworkflows.forEach(swf => {
            const swfNode = context.nodes[swf];
            const topLevel = context.core.getGuid(context.core.getParent(swfNode)) === context.core.getGuid(this.activeNode);
            const fileName = topLevel ? context.core.getAttribute(swfNode, 'name') + '_swf.cwl.json' : context.core.getGuid(swfNode) + '_swf.cwl.json';
            files[fileName] = this.processWorkflow(swfNode, files, artifacts);
            cwlContent.steps[context.core.getAttribute(swfNode, 'name')] = {
                run: fileName,
                in:{},
                out:[]
            };
        });

        //Finally: flows
        context.flows.forEach(flow => {
            if (flow.dstHost) {
                if(flow.scatter){
                    cwlContent.requirements['ScatterFeatureRequirement'] = {};
                    const scatterStep = cwlContent.steps[flow.dstHost];
                    scatterStep.scatterMethod = 'dotproduct';
                    scatterStep.scatter = scatterStep.scatter || [];
                    scatterStep.scatter.push(flow.dst);
                }
                cwlContent.steps[flow.dstHost].in[flow.dst] = flow.srcHost ? flow.srcHost + '/' + flow.src : flow.src;
            } else {
                cwlContent.outputs[flow.dst] = {
                    type: flow.type,
                    outputSource: flow.srcHost ? flow.srcHost + '/' + flow.src : flow.src 
                }
            }
            if(flow.srcHost && cwlContent.steps[flow.srcHost].out.indexOf(flow.src) === -1) {
                cwlContent.steps[flow.srcHost].out.push(flow.src);
            }
        });

        return cwlContent;
    };

    BuildWorkflow.prototype.getWorkflowContext = function(workflowNode) {
        const context = {
            inputs:[], 
            outputs:[], 
            steps:[], 
            subworkflows:[],
            flows:[], 
            core: this.core, 
            META: this.META, 
            nodes: this._nodes
        };

        const myPath = this.core.getPath(workflowNode);
        this.core.getChildrenPaths(workflowNode).forEach(childPath => {
            const childNode = this._nodes[childPath];
            if (this.core.isInstanceOf(childNode, this.META['Input'])) {
                context.inputs.push(childPath);
            } else if (this.core.isInstanceOf(childNode, this.META['Output'])) {
                context.outputs.push(childPath);
            } else if (this.core.isInstanceOf(childNode, this.META['Step'])) {
                context.steps.push(childPath);
            } else if (this.core.isInstanceOf(childNode, this.META['Workflow'])) {
                context.subworkflows.push(childPath);
            } else if (this.core.isInstanceOf(childNode, this.META['Flow'])) {
                //TODO this needs to be more sophisticated when it comes to scatter and merge patterns
                const element = {path: childPath};
                const srcHostNode = this.core.getParent(
                    this._nodes[this.core.getPointerPath(childNode, 'src')]);
                const dstHostNode = this.core.getParent(
                    this._nodes[this.core.getPointerPath(childNode, 'dst')]);
                element.srcHost = this.core.getPath(srcHostNode) === myPath ? 
                    null : this.core.getAttribute(srcHostNode, 'name');
                element.src = this.core.getAttribute(
                    this._nodes[this.core.getPointerPath(childNode, 'src')], 'name');
                element.dstHost = this.core.getPath(dstHostNode) === myPath ? 
                    null : this.core.getAttribute(dstHostNode, 'name');
                element.dst = this.core.getAttribute(
                    this._nodes[this.core.getPointerPath(childNode, 'dst')], 'name');
                
                if(!element.dstHost) {
                    if(this.core.isInstanceOf(
                        this._nodes[this.core.getPointerPath(childNode, 'dst')],
                        this.META['FileOutput'])) {
                            element.type = 'File';
                        }
                    else if(this.core.isInstanceOf(
                            this._nodes[this.core.getPointerPath(childNode, 'dst')],
                            this.META['FileArrayOutput'])) {
                                element.type = 'File[]';
                            }
                    else if(this.core.isInstanceOf(
                        this._nodes[this.core.getPointerPath(childNode, 'dst')],
                        this.META['DirectoryOutput'])) {
                            element.type = 'Directory';
                        }
                    else if(this.core.isInstanceOf(
                        this._nodes[this.core.getPointerPath(childNode, 'dst')],
                        this.META['DirectoryArrayOutput'])) {
                            element.type = 'Directory[]';
                        }
                    else if(this.core.isInstanceOf(
                        this._nodes[this.core.getPointerPath(childNode, 'dst')],
                        this.META['StringOutput'])) {
                            element.type = 'string';
                        }
                    else if(this.core.isInstanceOf(
                        this._nodes[this.core.getPointerPath(childNode, 'dst')],
                        this.META['StringArrayOutput'])) {
                            element.type = 'string';
                        }
                }

                //check for scatter
                const flowTypeName = this.core.getAttribute(this.core.getMetaType(childNode),'name');
                switch(flowTypeName) {
                    case 'FlowFai2Fi':
                    case 'FlowDai2Di':
                    case 'FlowSai2Si':
                        element.scatter = true;
                }

                context.flows.push(element);
            }
        });

        return context;
    };

    BuildWorkflow.prototype.getStepContext = function(stepNode, artifacts) {
        const context = {
            inputs:[], 
            outputs:[], 
            core: this.core, 
            META: this.META, 
            nodes: this._nodes,
            artifacts: artifacts
        };
        
        context.core.getChildrenPaths(stepNode).forEach(childPath => {
            if (context.core.isInstanceOf(this._nodes[childPath], this.META['Input'])) {
                context.inputs.push(childPath);
            } else if (context.core.isInstanceOf(this._nodes[childPath], this.META['Output'])) {
                context.outputs.push(childPath);
            } 
        });

        return context;
    };

    BuildWorkflow.prototype.processStep = function(stepNode, artifacts) {
        const context = this.getStepContext(stepNode, artifacts);
        const stepName = context.core.getAttribute(context.core.getMetaType(stepNode), 'name');
        return Steps[stepName](stepNode, context);
    };

    BuildWorkflow.prototype.generateArtifact = function(files, artifacts, mainInputs, saveDirectory) {
        // console.log('SAVE?',saveDirectory);
        const deferred = Q.defer();
        const fileNames = Object.keys(files);
        let fs = null;
        const artifactName = this.core.getAttribute(this.activeNode, 'name'); 
        const artifact = this.blobClient.createArtifact(artifactName);
        const promises = [];
        const saveToDisc = (path, content) => {
            const defd = Q.defer();
            const options = {};
            console.log('WO:', path);
            fs.writeFile(saveDirectory + '/' + path, content, err => {
                if (err) {
                    console.log('WO-err:', path);
                    defd.reject(err);
                } else {
                    console.log('WO-done:', path);
                    defd.resolve(null);
                }
            });
            return defd.promise;
        };

        if (saveDirectory) {
            fs = require('fs');
            fileNames.forEach(fileName => {
                if (fileName === 'README.md' || fileName === 'run.sh') {
                    promises.push(saveToDisc(fileName, files[fileName]));
                } else {
                    promises.push(saveToDisc(fileName, JSON.stringify(files[fileName], null, 2)));
                }
            });
            artifacts.forEach(fileinfo => {
                if (fileinfo.isDefaultDirectory) {
                    promises.push(saveToDisc(fileinfo.name + '/_default_', ''));
                } else {
                    promises.push(saveToDisc(fileinfo.name, fileinfo.content));
                }
            });
        } else {
            fileNames.forEach(fileName => {
                if (fileName === 'README.md' || fileName === 'run.sh') {
                    promises.push(artifact.addFile(fileName, files[fileName]));
                } else if (fileName) {
                    promises.push(artifact.addFile(fileName, JSON.stringify(files[fileName], null, 2)));
                }
            });
            artifacts.forEach(fileinfo => {
                if (fileinfo.name) {
                    if (fileinfo.isDefaultDirectory) {
                        promises.push(artifact.addFile(fileinfo.name + '/_default_', ''));
                    } else {
                        promises.push(artifact.addFile(fileinfo.name, fileinfo.content));
                    }
                }
            });
        }

        Q.all(promises)
        .then(results => {
            if(saveDirectory) {
                return Q(null);
            } else {
                return artifact.save();
            }
        })
        .then(artifactHash => {
            if (artifactHash) {
                this.result.addArtifact(artifactHash);
            }
            deferred.resolve(artifactHash);
        })
        .catch(deferred.reject);

        return deferred.promise;
    };

    return BuildWorkflow;
});
